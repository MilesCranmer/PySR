import{_ as s,c as a,o as e,aA as i}from"./chunks/framework.CHSKrKFr.js";const k=JSON.parse('{"title":"Operators","description":"","frontmatter":{},"headers":[],"relativePath":"operators.md","filePath":"operators.md","lastUpdated":1760143078000}'),d={name:"operators.md"};function o(n,t,r,h,l,p){return e(),a("div",null,[...t[0]||(t[0]=[i(`<h1 id="operators" tabindex="-1">Operators <a class="header-anchor" href="#operators" aria-label="Permalink to &quot;Operators&quot;">​</a></h1><h2 id="pre-defined" tabindex="-1">Pre-defined <a class="header-anchor" href="#pre-defined" aria-label="Permalink to &quot;Pre-defined&quot;">​</a></h2><p>First, note that pretty much any valid Julia function which takes one or two scalars as input, and returns on scalar as output, is likely to be a valid operator<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. A selection of these and other valid operators are stated below.</p><p>Also, note that it&#39;s a good idea to not use too many operators, since it can exponentially increase the search space.</p><h3 id="unary-operators" tabindex="-1">Unary Operators <a class="header-anchor" href="#unary-operators" aria-label="Permalink to &quot;Unary Operators&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Basic</th><th>Exp/Log</th><th>Trig</th><th>Hyperbolic</th><th>Special</th><th>Rounding</th></tr></thead><tbody><tr><td><code>neg</code></td><td><code>exp</code></td><td><code>sin</code></td><td><code>sinh</code></td><td><code>erf</code></td><td><code>round</code></td></tr><tr><td><code>square</code></td><td><code>log</code></td><td><code>cos</code></td><td><code>cosh</code></td><td><code>erfc</code></td><td><code>floor</code></td></tr><tr><td><code>cube</code></td><td><code>log10</code></td><td><code>tan</code></td><td><code>tanh</code></td><td><code>gamma</code></td><td><code>ceil</code></td></tr><tr><td><code>cbrt</code></td><td><code>log2</code></td><td><code>asin</code></td><td><code>asinh</code></td><td><code>relu</code></td><td></td></tr><tr><td><code>sqrt</code></td><td><code>log1p</code></td><td><code>acos</code></td><td><code>acosh</code></td><td><code>sinc</code></td><td></td></tr><tr><td><code>abs</code></td><td></td><td><code>atan</code></td><td><code>atanh</code></td><td></td><td></td></tr><tr><td><code>sign</code></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>inv</code></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="binary-operators" tabindex="-1">Binary Operators <a class="header-anchor" href="#binary-operators" aria-label="Permalink to &quot;Binary Operators&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Arithmetic</th><th>Comparison</th><th>Logic</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>max</code></td><td><code>logical_or</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></td></tr><tr><td><code>-</code></td><td><code>min</code></td><td><code>logical_and</code><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></td></tr><tr><td><code>*</code></td><td><code>&gt;</code><sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></td><td></td></tr><tr><td><code>/</code></td><td><code>&gt;=</code></td><td></td></tr><tr><td><code>^</code></td><td><code>&lt;</code></td><td></td></tr><tr><td></td><td><code>&lt;=</code></td><td></td></tr><tr><td></td><td><code>cond</code><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></td><td></td></tr><tr><td></td><td><code>mod</code></td><td></td></tr></tbody></table><h3 id="higher-arity-operators" tabindex="-1">Higher Arity Operators <a class="header-anchor" href="#higher-arity-operators" aria-label="Permalink to &quot;Higher Arity Operators&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Ternary</th></tr></thead><tbody><tr><td><code>clamp</code></td></tr><tr><td><code>fma</code> / <code>muladd</code></td></tr><tr><td><code>max</code></td></tr><tr><td><code>min</code></td></tr></tbody></table><p>Note that to use operators with arity 3 or more, you must use the <code>operators</code> parameter instead of the <code>*ary_operators</code> parameters, and pass operators as a dictionary with the arity as key:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">operators</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;+&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;clamp&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre></div><h2 id="custom" tabindex="-1">Custom <a class="header-anchor" href="#custom" aria-label="Permalink to &quot;Custom&quot;">​</a></h2><p>Instead of passing a predefined operator as a string, you can just define a custom function as Julia code. For example:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    PySRRegressor(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        ...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        unary_operators</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myfunction(x) = x^2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        binary_operators</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myotherfunction(x, y) = x^2*y&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">        extra_sympy_mappings</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot;myfunction&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">lambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x: x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot;myotherfunction&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">lambda</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x, y: x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span></code></pre></div><p>Make sure that it works with <code>Float32</code> as a datatype (for default precision, or <code>Float64</code> if you set <code>precision=64</code>). That means you need to write <code>1.5f3</code> instead of <code>1.5e3</code>, if you write any constant numbers, or simply convert a result to <code>Float64(...)</code>.</p><p>PySR expects that operators not throw an error for any input value over the entire real line from <code>-3.4e38</code> to <code>+3.4e38</code>. Thus, for invalid inputs, such as negative numbers to a <code>sqrt</code> function, you may simply return a <code>NaN</code> of the same type as the input. For example,</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">my_sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sqrt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> convert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NaN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>would be a valid operator. The genetic algorithm will preferentially selection expressions which avoid any invalid values over the training dataset.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>However, you will need to define a sympy equivalent in <code>extra_sympy_mapping</code> if you want to use a function not in the above list. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><code>logical_or</code> is equivalent to <code>(x, y) -&gt; (x &gt; 0 || y &gt; 0) ? 1 : 0</code> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><code>logical_and</code> is equivalent to <code>(x, y) -&gt; (x &gt; 0 &amp;&amp; y &gt; 0) ? 1 : 0</code> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><code>&gt;</code> is equivalent to <code>(x, y) -&gt; x &gt; y ? 1 : 0</code> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><code>cond</code> is equivalent to <code>(x, y) -&gt; x &gt; 0 ? y : 0</code> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>`,21)])])}const y=s(d,[["render",o]]);export{k as __pageData,y as default};
